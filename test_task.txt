1. Инициализируй Nest.JS приложение как по книжке. Добавь TypeORM подключение.
Желательно использовать при этом провайдеры и useFactory: async () =>
конструкцию, а так же ConfigModule из @nestjs/config для получения переменных
среды. Далее создай простейший CRUD RestAPI модуль для работы с простой
сущностью с полями. 

id: инкремент или uuidv4
title: varchar(255) -- обязательное поле
createdAt: datetime с точностью precission 6 (поле заполняется автоматически
при создании) -- обязательное поле
updatedAt: такой же тип только автоматическое обновление значения при
обновлении сущности записи -- опциональное поле
deletedAt: такой же тип, но проставляется только при soft delete -- опциональное
поле

- Заполнить автоматически таблицу на 100-1000 записей через seed, миграцию
typeorm, или скрипт вызываемый через npm/yarn случайным значениями

- В сервисе эндпоинта на получение нужно получать только неудалённые записи, 
отсортированные DESC по createdAt

- Использовать createQueryBuilder и модули class-validator, class-transformer
для написания DTO и валидации входящих тел и query строк 

- Добавить подзапрос для каждой записи на получение разницы (назвать поле
difference) по модулю в днях между createdAt и updatedAt. Возможно, для решения
понадобится поискать похожую проблему с computed column на github gist

- Добавить опциональные пагинацию и регистронезависимый поиск по вхождению
подстроки 

2. Приведи краткую интерпретацию лога ошибки (тип ошибки, что вызвало ошибку, 
возможное решение), указанного ниже: 

-------------------------------------------------------------------------------
AxiosError: Request failed with status code 404
 at settle (/home/www/dev-api.wame.tools.some/current/node_modules/axios/dist/node/axios.cjs: 2015: 12)
 at IncomingMessage.handleStreamEnd (/home/www/dev-api.wame.tools.some/current/node_modules/axios/dist/node/axios.cjs: 3131: 11)
 at IncomingMessage.emit (node: events: 530: 35)
 at IncomingMessage.emit (node: domain: 488: 12)
 at endReadableNT (node: internal/streams/readable: 1696: 12)
 at process.processTicksAndRejections (node: internal/process/task_queues: 82: 21)
 at Axios.request (/home/www/dev-api.wame.tools.some/current/node_modules/axios/dist/node/axios.cjs: 4262: 41)
 at process.processTicksAndRejections (node: internal/process/task_queues: 95: 5)
 at async HttpRequestsService.vitaminIdLoginWithAuthCode (/home/www/dev-api.wame.tools.some/current/dist/app/http-requests/http-requests.service.js: 428: 29)
 at async AuthService.loginWithAuthCode (/home/www/dev-api.wame.tools.some/current/dist/app/api/auth/auth.service.js: 608: 36)
-------------------------------------------------------------------------------


3. Какой шаблон проектирования реализован коде указанном ниже? 

-------------------------------------------------------------------------------
public async globalWs__(
    incomingAction: WsActionsAcceptingEnum,
    data: any,
    profile: ProfileRepository,
    socket: Socket
  ) {
    switch (incomingAction) {
      case WsActionsAcceptingEnum.TICKET_OPEN_TICKET:
        // open ticket
        await this.wsRoleCheck(profile, [
          ProfileRoleEnum.AUCTION,
          ProfileRoleEnum.EDTECH,
          ProfileRoleEnum.REAL_ESTATE,
          ProfileRoleEnum.COMMON,
          ProfileRoleEnum.FOOD,
        ]);
        return this.ticketOpen(
          await validateByClassUtil(data, WsTicketCreateDto),
          profile,
          socket
        );

      case WsActionsAcceptingEnum.TICKET_CLOSE_TICKET:
        await this.wsRoleCheck(profile, [
          ProfileRoleEnum.ADMIN,
          ProfileRoleEnum.MODERATOR,
        ]);
        return this.ticketClose(
          await validateByClassUtil(data, WsTicketCloseDto),
          socket
        );

      case WsActionsAcceptingEnum.GENERAL_SEND_MESSAGE:
        await this.wsRoleCheck(profile, []);
        return this.sendMessageToChat(
          profile,
          await validateByClassUtil(data, WsGeneralSendMessageDto),
          socket
        );

      default:
        return;
    }
  }
-------------------------------------------------------------------------------

4. Исходный код первого задания разместить на github или gitlab в открытом
репозитории, ответы на второе и третье задание написать в текстовике в корне
проекта в том же репозитории